
-- Load OrionLib with comprehensive error handling and multiple working fallbacks
local OrionLib
local orionSources = {
    "https://raw.githubusercontent.com/jensonhirst/Orion/main/source",
    "https://raw.githubusercontent.com/shlexware/Orion/main/source",
    "https://raw.githubusercontent.com/ionlyusegithubformcmods/1-Line-Scripts/main/Orion.lua",
    "https://raw.githubusercontent.com/ActualMasterOogway/Orion-Library/main/source.lua",
    "https://raw.githubusercontent.com/OrionLibrary/Orion/main/source"
}

local function loadOrionLib()
    for i, source in ipairs(orionSources) do
        local success, result = pcall(function()
            -- Add timeout and retry mechanism
            local httpSuccess, httpResult = pcall(function()
                return game:HttpGet(source, true)
            end)
            
            if not httpSuccess then
                error("HTTP request failed: " .. tostring(httpResult))
            end
            
            if not httpResult or httpResult == "" then
                error("Empty response from server")
            end
            
            -- Validate the response contains OrionLib code
            if not string.find(httpResult, "OrionLib") and not string.find(httpResult, "Orion") then
                error("Invalid OrionLib source - missing library identifier")
            end
            
            return loadstring(httpResult)()
        end)
        
        if success and result and type(result) == "table" then
            if i > 1 then
                warn("Successfully loaded OrionLib from fallback source #" .. i)
            else
                print("OrionLib loaded successfully from primary source")
            end
            return result
        else
            warn("Failed to load OrionLib from source #" .. i .. ": " .. tostring(result))
            wait(0.5) -- Brief delay before trying next source
        end
    end
    
    error("Critical error: All OrionLib sources failed to load. Please check your internet connection or try again later.")
end

-- Load OrionLib with comprehensive error handling
local loadSuccess, loadResult = pcall(loadOrionLib)
if loadSuccess then
    OrionLib = loadResult
    print("âœ… OrionLib loaded successfully!")
else
    warn("âŒ Critical error loading OrionLib: " .. tostring(loadResult))
    warn("ðŸ’¡ Possible solutions:")
    warn("   1. Check your internet connection")
    warn("   2. Ensure HttpService is enabled in game settings")
    warn("   3. Try again in a few minutes")
    warn("   4. Contact script developer if issue persists")
    return
end 

-- Create main Window with comprehensive error handling and mobile optimizations
local Window
local windowSuccess, windowError = pcall(function()
    return OrionLib:MakeWindow({
        Name = "Ascender Incremental Hub",
        HidePremium = false,
        SaveConfig = true,
        ConfigFolder = "AscenderIncrementalConfig",
        IntroEnabled = false, -- Disabled to prevent intro-related errors
        IntroText = "Ascender Incremental Script",
        -- Icon removed to prevent Frame property errors
        CloseCallback = function()
            print("Ascender Incremental Hub closed")
        end
    })
end)

if windowSuccess then
    Window = windowError
    print("âœ… Main window created successfully!")
else
    warn("âŒ Failed to create main window: " .. tostring(windowError))
    warn("ðŸ’¡ This might be due to OrionLib compatibility issues")
    return
end

-- Verify window was created properly
if not Window then
    warn("Failed to create OrionLib window: " .. tostring(windowError))
    return
end

-- Mobile optimization: Make GUI draggable and touch-friendly
local function optimizeForMobile()
    local success, err = pcall(function()
        if game:GetService("UserInputService").TouchEnabled then
            -- Mobile device detected, apply optimizations
            local coreGui = game:GetService("CoreGui")
            local orionGui = coreGui:FindFirstChild("Orion")
            if orionGui and orionGui:FindFirstChild("Main") then
                local mainFrame = orionGui.Main
                mainFrame.Active = true
                mainFrame.Draggable = true
                
                -- Improve touch responsiveness
                for _, descendant in pairs(mainFrame:GetDescendants()) do
                    if descendant:IsA("GuiButton") or descendant:IsA("TextButton") then
                        descendant.AutoButtonColor = true
                        descendant.Active = true
                    elseif descendant:IsA("Frame") and descendant.Name:find("Slider") then
                        descendant.Active = true
                    end
                end
            end
        end
    end)
    
    if not success then
        warn("Mobile optimization failed: " .. tostring(err))
    end
end

-- Apply mobile optimizations after a short delay
task.spawn(function()
    task.wait(1)
    optimizeForMobile()
    
    -- Additional draggable fix for mobile
    task.wait(1)
    local function fixDraggableForMobile()
        local success, err = pcall(function()
            local UserInputService = game:GetService("UserInputService")
            if UserInputService.TouchEnabled then
                local coreGui = game:GetService("CoreGui")
                local orionGui = coreGui:FindFirstChild("Orion")
                if orionGui and orionGui:FindFirstChild("Main") then
                    local mainFrame = orionGui.Main
                    
                    -- Custom draggable implementation for mobile
                    local dragging = false
                    local dragInput
                    local dragStart
                    local startPos
                    
                    local function update(input)
                        local delta = input.Position - dragStart
                        mainFrame.Position = UDim2.new(
                            startPos.X.Scale, 
                            startPos.X.Offset + delta.X, 
                            startPos.Y.Scale, 
                            startPos.Y.Offset + delta.Y
                        )
                    end
                    
                    mainFrame.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            dragging = true
                            dragStart = input.Position
                            startPos = mainFrame.Position
                            
                            input.Changed:Connect(function()
                                if input.UserInputState == Enum.UserInputState.End then
                                    dragging = false
                                end
                            end)
                        end
                    end)
                    
                    mainFrame.InputChanged:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                            dragInput = input
                        end
                    end)
                    
                    UserInputService.InputChanged:Connect(function(input)
                        if input == dragInput and dragging then
                            update(input)
                        end
                    end)
                end
            end
        end)
        
        if not success then
            warn("Draggable fix failed: " .. tostring(err))
        end
    end
    
    fixDraggableForMobile()
end)

-- Create Tabs with error handling
local MainTab, TeleportTab, ConfigTab, StatsTab, SettingsTab

local function createTabs()
    MainTab = Window:MakeTab({
        Name = "Main",
        PremiumOnly = false
    })
    
    TeleportTab = Window:MakeTab({
        Name = "Teleport",
        PremiumOnly = false
    })
    
    ConfigTab = Window:MakeTab({
        Name = "Config",
        PremiumOnly = false
    })
    
    StatsTab = Window:MakeTab({
        Name = "Stats",
        PremiumOnly = false
    })
    
    SettingsTab = Window:MakeTab({
        Name = "Settings",
        PremiumOnly = false
    })
end

local tabSuccess, tabError = pcall(createTabs)
if not tabSuccess then
    warn("Failed to create tabs: " .. tostring(tabError))
    return
end

-- Services and Events
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Initialize Events with error handling
local BuyUpgrade, TeleportRealm
local function initializeEvents()
    local success, err = pcall(function()
        if ReplicatedStorage:FindFirstChild("Framework") and 
           ReplicatedStorage.Framework:FindFirstChild("Events") then
            if ReplicatedStorage.Framework.Events:FindFirstChild("Buy_Upgrade") then
                BuyUpgrade = ReplicatedStorage.Framework.Events.Buy_Upgrade
            end
            if ReplicatedStorage.Framework.Events:FindFirstChild("Teleport_Realm") then
                TeleportRealm = ReplicatedStorage.Framework.Events.Teleport_Realm
            end
        end
    end)
    
    if not success then
        warn("Failed to initialize events: " .. tostring(err))
    end
end

initializeEvents()

-- State variables with validation
local autoUpgradeEnabled = false
local selectedUpgradeType = "W1"
local currentPosition = "Unknown"
local scriptRunning = true
local antiAfkEnabled = true
local autoAllRuneEnabled = false
local autoAllRuneSpeed = 2

-- Config system
local configFolderName = "AscenderIncrementalConfigs"
local defaultConfigName = "default"
local currentConfigName = defaultConfigName
local defaultConfig = {
    antiAfkEnabled = false,
    autoUpgradeEnabled = false,
    selectedUpgradeType = "W1",
    autoAllRuneEnabled = false,
    autoAllRuneSpeed = 2,
    autoChromatizeEnabled = false,
    chromatizeCheckInterval = 1
}

local function getConfigPath(configName)
    return configFolderName .. "/" .. configName .. ".json"
end

local function ensureConfigFolder()
    local success, err = pcall(function()
        if not isfolder(configFolderName) then
            makefolder(configFolderName)
        end
    end)
    
    if not success then
        OrionLib:MakeNotification({
            Name = "Config Error",
            Content = "Failed to create config folder: " .. tostring(err),
            Time = 3
        })
        return false
    end
    return true
end

local function getConfigList()
    ensureConfigFolder()
    local configs = {}
    
    local success, files = pcall(function()
        return listfiles(configFolderName)
    end)
    
    if success and files then
        for _, file in ipairs(files) do
            local success2, fileName = pcall(function()
                -- Extract filename from full path using string operations
                local name = file
                
                -- Find last slash (both / and \)
                local lastSlash = 0
                for i = 1, #name do
                    local char = name:sub(i, i)
                    if char == "/" or char == "\\" then
                        lastSlash = i
                    end
                end
                
                if lastSlash > 0 then
                    name = name:sub(lastSlash + 1)
                end
                
                -- Check if it's a .json file and remove extension
                if name:sub(-5) == ".json" then
                    local configName = name:sub(1, -6)
                    if configName and configName ~= "" and configName ~= defaultConfigName then
                        return configName
                    end
                end
                return nil
            end)
            
            if success2 and fileName then
                table.insert(configs, fileName)
            end
        end
    end
    
    -- Always include default config at the beginning
    table.insert(configs, 1, defaultConfigName)
    
    return configs
end

local function saveConfig(configName)
    configName = configName or currentConfigName
    if not configName or configName == "" then
        configName = defaultConfigName
    end
    
    ensureConfigFolder()
    
    local config = {
        antiAfkEnabled = antiAfkEnabled,
        autoUpgradeEnabled = autoUpgradeEnabled,
        selectedUpgradeType = selectedUpgradeType,
        autoAllRuneEnabled = autoAllRuneEnabled,
        autoAllRuneSpeed = autoAllRuneSpeed,
        autoChromatizeEnabled = autoChromatizeEnabled,
        chromatizeCheckInterval = chromatizeCheckInterval
    }
    
    local success, err = pcall(function()
        local jsonString = game:GetService("HttpService"):JSONEncode(config)
        writefile(getConfigPath(configName), jsonString)
    end)
    
    if success then
        currentConfigName = configName
        
        -- Update UI elements if they exist
        if currentConfigLabel then
            currentConfigLabel:Set("Current Config: " .. currentConfigName)
        end
        
        OrionLib:MakeNotification({
            Name = "Config",
            Content = "Configuration '" .. configName .. "' saved successfully!",
            Time = 2
        })
    else
        OrionLib:MakeNotification({
            Name = "Config Error",
            Content = "Failed to save configuration: " .. tostring(err),
            Time = 3
        })
    end
end

local function loadConfig(configName)
    configName = configName or currentConfigName
    if not configName or configName == "" then
        configName = defaultConfigName
    end
    
    ensureConfigFolder()
    
    local success, result = pcall(function()
        local configPath = getConfigPath(configName)
        if isfile(configPath) then
            local jsonString = readfile(configPath)
            return game:GetService("HttpService"):JSONDecode(jsonString)
        else
            return defaultConfig
        end
    end)
    
    if success and result then
        antiAfkEnabled = result.antiAfkEnabled or defaultConfig.antiAfkEnabled
        autoUpgradeEnabled = result.autoUpgradeEnabled or defaultConfig.autoUpgradeEnabled
        selectedUpgradeType = result.selectedUpgradeType or defaultConfig.selectedUpgradeType
        autoAllRuneEnabled = result.autoAllRuneEnabled or defaultConfig.autoAllRuneEnabled
        autoAllRuneSpeed = result.autoAllRuneSpeed or defaultConfig.autoAllRuneSpeed
        autoChromatizeEnabled = result.autoChromatizeEnabled or defaultConfig.autoChromatizeEnabled
        chromatizeCheckInterval = result.chromatizeCheckInterval or defaultConfig.chromatizeCheckInterval
        
        currentConfigName = configName
        
        -- Update UI elements if they exist
        if currentConfigLabel then
            currentConfigLabel:Set("Current Config: " .. currentConfigName)
        end
        
        OrionLib:MakeNotification({
            Name = "Config",
            Content = "Configuration '" .. configName .. "' loaded successfully!",
            Time = 2
        })
    else
        -- Use default values
        antiAfkEnabled = defaultConfig.antiAfkEnabled
         autoUpgradeEnabled = defaultConfig.autoUpgradeEnabled
         selectedUpgradeType = defaultConfig.selectedUpgradeType
         autoAllRuneEnabled = defaultConfig.autoAllRuneEnabled
         autoAllRuneSpeed = defaultConfig.autoAllRuneSpeed
         autoChromatizeEnabled = defaultConfig.autoChromatizeEnabled
         chromatizeCheckInterval = defaultConfig.chromatizeCheckInterval
        
        OrionLib:MakeNotification({
            Name = "Config Error",
            Content = "Failed to load configuration '" .. configName .. "', using defaults",
            Time = 3
        })
    end
end

-- Upgrade list for Ascender Incremental
local upgradeListW1 = {
    { name = "Prisms_Energy1", times = 1 },
    { name = "Prisms_Flame1", times = 3 },
    { name = "Prisms_Prisms1", times = 1 },
    { name = "Prisms_Power", times = 5 },
    { name = "Prisms_Multi", times = 2 },
    { name = "Prisms_Prisms2", times = 1 },
    { name = "Prisms_RP1", times = 2 },
    { name = "Prisms_Orbs2", times = 3 },
    { name = "Prisms_Energy2", times = 1 },
    { name = "Prisms_Prisms3", times = 2 },
    { name = "Prisms_RPEnhance", times = 1 },
    { name = "Prisms_Flesh3", times = 1 },
    { name = "Prisms_Accelerator", times = 6 },
    { name = "Prisms_RuneLuck", times = 2 },
    { name = "Prisms_RuneLuck2", times = 1 },
    { name = "Prisms_SpheresEnhance", times = 1 },
    { name = "Prisms_Flame2", times = 2 },
    { name = "Prisms_OrbsEnhance", times = 1 },
    { name = "Prisms_Tickets", times = 1 },
    { name = "Prisms_AutoPower", times = 1 },
    { name = "Prisms_AutoPower2", times = 19 },
    { name = "Prisms_AutoPower3", times = 19 },
    { name = "Prisms_Caps", times = 2 },
    { name = "Prisms_RuneBulk", times = 2 },
    { name = "Prisms_OrbsAutoBuy", times = 1 },
    { name = "Prisms_AutoFlame", times = 1 },
    { name = "Prisms_Spheres2", times = 3 },
    { name = "Prisms_RP2", times = 1 },
    { name = "Prisms_Spheres1", times = 5 },
    { name = "Prisms_Prisms4", times = 1 },
    { name = "Prisms_Damage", times = 3 },
    { name = "Prisms_Walkspeed", times = 1 },
    { name = "Prisms_RuneSpeed", times = 1 },
    { name = "Prisms_DMG", times = 1 },
    { name = "Prisms_Flesh", times = 2 },
    { name = "Prisms_AutoAttack", times = 1 },
    { name = "Prisms_SpawnSpeed", times = 12 },
    { name = "Prisms_AutoLevel", times = 1 },
    { name = "Prisms_AutoAttackSpeed", times = 9 },
    { name = "Prisms_Orbs1", times = 4 },
    { name = "Prisms_Spheres3", times = 1 },
    { name = "Prisms_Spheres4", times = 1 },
    { name = "Prisms_Flesh2", times = 1 }
}

local upgradeListW2 = {
    { name = "Prisms_Droplets1", times = 5 },
    { name = "Prisms_Water1", times = 3 },
    { name = "Prisms_Droplets2", times = 1 },
    { name = "Prisms_Spheres5", times = 4 },
    { name = "Prisms_Chromium1", times = 4 },
    { name = "Chromium_Chromium1", times = 2 },
    { name = "Chromium_Chromium2", times = 3 },
    { name = "Chromium_Droplets1", times = 4 },
    { name = "Chromium_AP3", times = 1 },
    { name = "Chromium_SpheresEnhance", times = 1 },
    { name = "Chromium_Prisms1", times = 2 },
    { name = "Chromium_Prisms2", times = 1 },
    { name = "Chromium_Prisms3", times = 1 },
    { name = "Chromium_Prisms4", times = 1 },
    { name = "Chromium_Prisms5", times = 5 },
    { name = "Chromium_Automation1", times = 1 },
    { name = "Chromium_RuneSpeed", times = 1 },
    { name = "Chromium_Icicles2", times = 1 },
    { name = "Chromium_Icicles1", times = 6 },
    { name = "Prisms_AP1", times = 1 },
    { name = "Chromium_Ice1", times = 4 },
    { name = "Chromium_Ice2", times = 1 },
    { name = "Chromium_Water1", times = 3 },
    { name = "Chromium_Multi1", times = 2 },
    { name = "Chromium_Automation2", times = 1 },
    { name = "Chromium_Automation3", times = 19 },
    { name = "Chromium_Chromium3", times = 4 },
    { name = "Chromium_Droplets2", times = 2 },
    { name = "Chromium_AP1", times = 5 },
    { name = "Chromium_AP2", times = 3 },
    { name = "Chromium_AP4", times = 1 },
    { name = "Chromium_Icicles3", times = 1 },
    { name = "Chromium_AP5", times = 1 },
    { name = "Chromium_Chromium4", times = 1 },
    { name = "Chromium_Chromium5", times = 1 },
    { name = "Chromium_AP6", times = 5},
    { name = "Chromium_Icicles4", times = 1},
    { name = "Chromium_RuneStarring", times = 1}
}

-- Create W1+W2 list (combine both)
local upgradeListW1W2 = {}
for _, upgrade in ipairs(upgradeListW1) do
    table.insert(upgradeListW1W2, upgrade)
end
for _, upgrade in ipairs(upgradeListW2) do
    table.insert(upgradeListW1W2, upgrade)
end

-- Teleport positions list
local teleportPositions = {
    ["Spawn"] = Vector3.new(0, 5, 0),
    ["Shop"] = Vector3.new(50, 5, 0),
    ["Upgrade Area"] = Vector3.new(-50, 5, 0),
    ["Farm Zone"] = Vector3.new(0, 5, 50)
}

-- Utility functions
local function safeFireServer(event, ...)
    local args = {...}
    local maxRetries = 3
    local retryCount = 0
    
    while retryCount < maxRetries do
        local success, err = pcall(function()
            if event and event:IsA("RemoteEvent") then
                event:FireServer(unpack(args))
                return true
            else
                error("Invalid RemoteEvent: " .. tostring(event))
            end
        end)
        
        if success then
            return true
        else
            retryCount = retryCount + 1
            warn("Error firing server (attempt " .. retryCount .. "/" .. maxRetries .. "): " .. tostring(err))
            if retryCount < maxRetries then
                task.wait(0.5) -- Wait before retry
            end
        end
    end
    
    return false
end

local function teleportToPosition(position)
    local success, err = pcall(function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(position)
        else
            warn("Character or HumanoidRootPart not found")
        end
    end)
    
    if not success then
        warn("Teleport failed: " .. tostring(err))
    end
end

local function getCurrentPosition()
    local success, result = pcall(function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local pos = LocalPlayer.Character.HumanoidRootPart.Position
            return string.format("X: %.1f, Y: %.1f, Z: %.1f", pos.X, pos.Y, pos.Z)
        end
        return "Character not found"
    end)
    
    if success then
        return result
    else
        return "Error getting position"
    end
end

-- TAB MAIN
MainTab:AddLabel("Auto Features")

MainTab:AddToggle({
    Name = "Anti AFK",
    Default = false,
    Callback = function(Value)
        antiAfkEnabled = Value
        OrionLib:MakeNotification({
            Name = "Anti AFK",
            Content = Value and "Anti AFK enabled" or "Anti AFK disabled",
            Time = 2
        })
    end
})

-- TAB CONFIG
ConfigTab:AddLabel("Configuration Management")

currentConfigLabel = ConfigTab:AddLabel("Current Config: " .. currentConfigName)

ConfigTab:AddTextbox({
    Name = "Create New Config",
    Default = "",
    TextDisappear = true,
    Callback = function(Value)
        if Value and Value ~= "" then
            local configName = Value:gsub("[^%w%s%-_]", ""):gsub("%s+", "_") -- Remove special characters and replace spaces with underscores
            if configName ~= "" and configName ~= "_" then
                saveConfig(configName)
                currentConfigLabel:Set("Current Config: " .. currentConfigName)
                -- Refresh dropdown to show new config
                local configs = getConfigList()
                configDropdown:Refresh(configs, true)
            else
                OrionLib:MakeNotification({
                    Name = "Config Error",
                    Content = "Invalid config name! Use letters, numbers, spaces, hyphens, or underscores only.",
                    Time = 3
                })
            end
        end
    end
})

local configDropdown = ConfigTab:AddDropdown({
    Name = "Load Configuration",
    Default = currentConfigName,
    Options = getConfigList(),
    Callback = function(Value)
        if Value and Value ~= "" and Value ~= currentConfigName then
            loadConfig(Value)
            OrionLib:MakeNotification({
                Name = "Config",
                Content = "Switched to configuration: " .. Value,
    
                Time = 2
            })
        end
    end
})

ConfigTab:AddButton({
    Name = "Refresh Config List",
    Callback = function()
        local configs = getConfigList()
        configDropdown:Refresh(configs, true) -- Force refresh
        OrionLib:MakeNotification({
            Name = "Config",
            Content = "Config list refreshed! Found " .. #configs .. " configs",
    
            Time = 2
        })
    end
})

ConfigTab:AddButton({
    Name = "Load Selected Config",
    Callback = function()
        local selectedConfig = configDropdown.Value or currentConfigName
        if selectedConfig and selectedConfig ~= "" then
            loadConfig(selectedConfig)
        else
            OrionLib:MakeNotification({
                Name = "Config Error",
                Content = "No config selected to load!",

                Time = 3
            })
        end
    end
})

ConfigTab:AddButton({
    Name = "Save Current Config",
    Callback = function()
        if currentConfigName and currentConfigName ~= "" then
            saveConfig(currentConfigName)
        else
            OrionLib:MakeNotification({
                Name = "Config Error",
                Content = "No config name specified. Please create a new config first.",
                Time = 3
            })
        end
    end
})

ConfigTab:AddButton({
    Name = "Remove Selected Config",
    Callback = function()
        local selectedConfig = configDropdown.Value or currentConfigName
        if selectedConfig and selectedConfig ~= "" and selectedConfig ~= defaultConfigName then
            local success, err = pcall(function()
                local configPath = getConfigPath(selectedConfig)
                if isfile(configPath) then
                    delfile(configPath)
                    return true
                else
                    error("Config file not found")
                end
            end)
            
            if success then
                -- Refresh dropdown to remove deleted config
                local configs = getConfigList()
                configDropdown:Refresh(configs, true)
                
                -- If deleted config was current, switch to default
                if selectedConfig == currentConfigName then
                    loadConfig(defaultConfigName)
                end
                
                OrionLib:MakeNotification({
                    Name = "Config",
                    Content = "Configuration '" .. selectedConfig .. "' removed successfully!",
                    Time = 2
                })
            else
                OrionLib:MakeNotification({
                    Name = "Config Error",
                    Content = "Failed to remove configuration: " .. tostring(err),
                    Time = 3
                })
            end
        else
            OrionLib:MakeNotification({
                Name = "Config Error",
                Content = selectedConfig == defaultConfigName and "Cannot remove default config!" or "No config selected to remove!",
                Time = 3
            })
        end
    end
})

ConfigTab:AddButton({
    Name = "Reset to Default",
    Callback = function()
        antiAfkEnabled = defaultConfig.antiAfkEnabled
        autoUpgradeEnabled = defaultConfig.autoUpgradeEnabled
        selectedUpgradeType = defaultConfig.selectedUpgradeType
        autoAllRuneEnabled = defaultConfig.autoAllRuneEnabled
        autoAllRuneSpeed = defaultConfig.autoAllRuneSpeed
        autoChromatizeEnabled = defaultConfig.autoChromatizeEnabled
        chromatizeCheckInterval = defaultConfig.chromatizeCheckInterval
        
        OrionLib:MakeNotification({
            Name = "Config",
            Content = "Configuration reset to default values!",
            Time = 2
        })
    end
})

ConfigTab:AddLabel("Auto Save")

ConfigTab:AddToggle({
    Name = "Auto Save Config",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Auto save every 30 seconds
            task.spawn(function()
                while Value and scriptRunning do
                    task.wait(30)
                    if Value and currentConfigName then
                        local success = pcall(function()
                            saveConfig(currentConfigName)
                        end)
                        if not success then
                            print("Auto-save failed for config: " .. tostring(currentConfigName))
                        end
                    end
                end
            end)
        end
        
        OrionLib:MakeNotification({
            Name = "Auto Save",
            Content = Value and "Auto save enabled (every 30s)" or "Auto save disabled",
            Time = 2
        })
    end
})

ConfigTab:AddLabel("Current Config Info")

ConfigTab:AddButton({
    Name = "Show Current Settings",
    Callback = function()
        local configInfo = string.format(
            "Config: %s\nAnti AFK: %s\nAuto Upgrade: %s\nUpgrade Type: %s\nAuto All Rune: %s\nRune Speed: %.2fs\nAuto Chromatizer: %s\nCheck Interval: %.1fs",
            currentConfigName,
            antiAfkEnabled and "ON" or "OFF",
            autoUpgradeEnabled and "ON" or "OFF",
            selectedUpgradeType,
            autoAllRuneEnabled and "ON" or "OFF",
            autoAllRuneSpeed,
            autoChromatizeEnabled and "ON" or "OFF",
            chromatizeCheckInterval
        )
        
        OrionLib:MakeNotification({
            Name = "Current Settings",
            Content = configInfo,
            Time = 5
        })
    end
})

MainTab:AddDropdown({
    Name = "Select Upgrade Type",
    Default = "W1",
    Options = {"W1", "W2", "W1+W2"},
    Callback = function(Value)
        selectedUpgradeType = Value
        OrionLib:MakeNotification({
            Name = "Upgrade Type",
            Content = "Selected upgrade type: " .. Value,
            Time = 2
        })
    end
})

MainTab:AddToggle({
    Name = "Auto Upgrade",
    Default = false,
    Callback = function(Value)
        autoUpgradeEnabled = Value
        OrionLib:MakeNotification({
            Name = "Auto Upgrade",
            Content = Value and "Auto Upgrade enabled (" .. selectedUpgradeType .. ")" or "Auto Upgrade disabled",
            Time = 3
        })
    end
})

MainTab:AddToggle({
    Name = "Auto All Rune (RISK)",
    Default = false,
    Callback = function(Value)
        autoAllRuneEnabled = Value
        OrionLib:MakeNotification({
            Name = "Auto All Rune",
            Content = Value and "Auto All Rune enabled - RISK MODE!" or "Auto All Rune disabled",
            Time = 3
        })
    end
})

-- Speed setting for both Auto All Rune and Auto Rune
MainTab:AddTextbox({
    Name = "Rune Speed (seconds)",
    Default = "2",
    TextDisappear = false,
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 0.01 and numValue <= 10 then
            autoAllRuneSpeed = numValue
            OrionLib:MakeNotification({
                Name = "Speed Setting",
                Content = "Rune speed set to " .. string.format("%.2f", numValue) .. " seconds",
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "Invalid Input",
                Content = "Please enter a number between 0.01 and 10",
                Time = 3
            })
        end
    end
})

-- Chromatizer Check Interval
MainTab:AddTextbox({
    Name = "Chromatizer Check Interval (seconds)",
    Default = tostring(chromatizeCheckInterval),
    TextDisappear = false,
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 0.1 and numValue <= 10 then
            chromatizeCheckInterval = numValue
            OrionLib:MakeNotification({
                Name = "Check Interval",
                Content = "Chromatizer check interval set to " .. string.format("%.1f", numValue) .. " seconds",
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "Invalid Input",
                Content = "Please enter a number between 0.1 and 10",
                Time = 3
            })
        end
    end
})

-- Auto Rune (Single Rune Selection)
local autoRuneEnabled = false
local selectedRune = "5M Beginner"

-- Auto Chromatizer Level
local autoChromatizeEnabled = false
local chromatizeCheckInterval = 1
local prismsValue = 0
local chromiumValue = 0

local runeList = {
    "5M Beginner",
    "5M Royal", 
    "Basic Rune",
    "Color Rune",
    "Nature Rune",
    "Polychrome Rune",
    "Cryo Rune",
    "Arctic Rune"
}

MainTab:AddDropdown({
    Name = "Select Rune",
    Default = "5M Beginner",
    Options = runeList,
    Callback = function(Value)
        selectedRune = Value
        OrionLib:MakeNotification({
            Name = "Rune Selection",
            Content = "Selected rune: " .. Value,
            Time = 2
        })
    end
})

MainTab:AddToggle({
    Name = "Auto Rune",
    Default = false,
    Callback = function(Value)
        autoRuneEnabled = Value
        OrionLib:MakeNotification({
            Name = "Auto Rune",
            Content = Value and "Auto Rune enabled for " .. selectedRune or "Auto Rune disabled",
            Time = 2
        })
    end
})

-- Auto Chromatizer Level Section
MainTab:AddLabel("Auto Chromatizer Level")

MainTab:AddToggle({
    Name = "Auto Chromatizer Level",
    Default = autoChromatizeEnabled,
    Callback = function(Value)
        autoChromatizeEnabled = Value
        OrionLib:MakeNotification({
            Name = "Auto Chromatizer",
            Content = Value and "Auto Chromatizer Level enabled" or "Auto Chromatizer Level disabled",
            Time = 2
        })
    end
})

-- TAB STATS
StatsTab:AddLabel("Game Statistics Monitor")

local PrismsLabel = StatsTab:AddLabel("Prisms: Loading...")
local ChromiumLabel = StatsTab:AddLabel("Chromium: Loading...")
local EnergyLabel = StatsTab:AddLabel("Energy: Loading...")
local FlameLabel = StatsTab:AddLabel("Flame: Loading...")
local PowerLabel = StatsTab:AddLabel("Power: Loading...")
local RPLabel = StatsTab:AddLabel("Realm Points: Loading...")
local FleshLabel = StatsTab:AddLabel("Flesh: Loading...")
local APLabel = StatsTab:AddLabel("Arctic Points: Loading...")

StatsTab:AddLabel("Chromatizer Info")
local ChromatizerPriceLabel = StatsTab:AddLabel("Chromatizer Price: Loading...")

-- TAB TELEPORT
TeleportTab:AddLabel("Quick Teleport")

TeleportTab:AddButton({
    Name = "5M Beginner",
    Callback = function()
        local success, err = pcall(function()
            local button = workspace.Areas["Spawn Island"].Beginner.Basic.Button
            if button and button.CFrame then
                local pos = button.CFrame.Position
                teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
            else
                error("Button not found")
            end
        end)
        
        OrionLib:MakeNotification({
            Name = "Quick Teleport",
            Content = success and "Teleported to 5M Beginner" or "Failed to teleport to 5M Beginner",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "5M Royal",
    Callback = function()
        local success, err = pcall(function()
            local button = workspace.Areas["Spawn Island"].Royal.Basic.Button
            if button and button.CFrame then
                local pos = button.CFrame.Position
                teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
            else
                error("Button not found")
            end
        end)
        
        OrionLib:MakeNotification({
            Name = "Quick Teleport",
            Content = success and "Teleported to 5M Royal" or "Failed to teleport to 5M Royal",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Basic Rune",
    Callback = function()
        local success, err = pcall(function()
            local button = workspace.Areas["Spawn Island"].Basic.Basic.Button
            if button and button.CFrame then
                local pos = button.CFrame.Position
                teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
            else
                error("Button not found")
            end
        end)
        
        OrionLib:MakeNotification({
            Name = "Quick Teleport",
            Content = success and "Teleported to Basic Rune" or "Failed to teleport to Basic Rune",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Color Rune",
    Callback = function()
        local success, err = pcall(function()
            local button = workspace.Areas["Spawn Island"].Color.Color.Button
            if button and button.CFrame then
                local pos = button.CFrame.Position
                teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
            else
                error("Button not found")
            end
        end)
        
        OrionLib:MakeNotification({
            Name = "Quick Teleport",
            Content = success and "Teleported to Color Rune" or "Failed to teleport to Color Rune",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Nature Rune",
    Callback = function()
        local success, err = pcall(function()
            local button = workspace.Areas["Spawn Island"].Nature.Nature.Button
            if button and button.CFrame then
                local pos = button.CFrame.Position
                teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
            else
                error("Button not found")
            end
        end)
        
        OrionLib:MakeNotification({
            Name = "Quick Teleport",
            Content = success and "Teleported to Nature Rune" or "Failed to teleport to Nature Rune",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Polychrome Rune",
    Callback = function()
        local success, err = pcall(function()
            local button = workspace.Areas["Spawn Island"].Polychrome.Polychrome.Button
            if button and button.CFrame then
                local pos = button.CFrame.Position
                teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
            else
                error("Button not found")
            end
        end)
        
        OrionLib:MakeNotification({
            Name = "Quick Teleport",
            Content = success and "Teleported to Polychrome Rune" or "Failed to teleport to Polychrome Rune",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Cryo Rune",
    Callback = function()
        local success, err = pcall(function()
            local button = workspace.Areas.Arctic.Cryo.Cryo.Button
            if button and button.CFrame then
                local pos = button.CFrame.Position
                teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
            else
                error("Button not found")
            end
        end)
        
        OrionLib:MakeNotification({
            Name = "Quick Teleport",
            Content = success and "Teleported to Cryo Rune" or "Failed to teleport to Cryo Rune",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Arctic Rune",
    Callback = function()
        local success, err = pcall(function()
            local button = workspace.Areas.Arctic.Arctic.Arctic.Button
            if button and button.CFrame then
                local pos = button.CFrame.Position
                teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
            else
                error("Button not found")
            end
        end)
        
        OrionLib:MakeNotification({
            Name = "Quick Teleport",
            Content = success and "Teleported to Arctic Rune" or "Failed to teleport to Arctic Rune",
            Time = 2
        })
    end
})

TeleportTab:AddLabel("Area Teleport")

TeleportTab:AddButton({
    Name = "Teleport to Realm 1",
    Callback = function()
        safeFireServer(TeleportRealm, "R1")
        OrionLib:MakeNotification({
            Name = "Area Teleport",
            Content = "Teleported to Realm 1",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Teleport to Realm 2",
    Callback = function()
        safeFireServer(TeleportRealm, "R2")
        OrionLib:MakeNotification({
            Name = "Area Teleport",
            Content = "Teleported to Realm 2",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Hall Of Fame",
    Callback = function()
        teleportToPosition(Vector3.new(4.1, -50.7, -48.6))
        OrionLib:MakeNotification({
            Name = "Area Teleport",
            Content = "Teleported to Hall Of Fame",
            Time = 2
        })
    end
})

TeleportTab:AddLabel("Talent Tree Locations")

TeleportTab:AddButton({
    Name = "Talent Tree W1 (Location 1)",
    Callback = function()
        teleportToPosition(Vector3.new(-770.5, -7.6, 1369.0))
        OrionLib:MakeNotification({
            Name = "Teleport",
            Content = "Teleported to Talent Tree W1 (Position 1)",
            Time = 2
        })
    end
})

TeleportTab:AddButton({
    Name = "Talent Tree W2 (Location 2)",
    Callback = function()
        teleportToPosition(Vector3.new(1225.6, 0.8, 301.7))
        OrionLib:MakeNotification({
            Name = "Teleport",
            Content = "Teleported to Talent Tree W2 (Position 2)",
            Time = 2
        })
    end
})

-- TAB SETTINGS
SettingsTab:AddLabel("Player Information")

local PositionLabel = SettingsTab:AddLabel("Position: " .. getCurrentPosition())

SettingsTab:AddButton({
    Name = "Check Position",
    Callback = function()
        currentPosition = getCurrentPosition()
        PositionLabel:Set("Position: " .. currentPosition)
        OrionLib:MakeNotification({
            Name = "Position Check",
            Content = "Current position: " .. currentPosition,
            Time = 3
        })
    end
})

SettingsTab:AddButton({
    Name = "Copy Position",
    Callback = function()
        local success, err = pcall(function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local pos = LocalPlayer.Character.HumanoidRootPart.Position
                local positionText = string.format("X:%.1f Y:%.1f Z:%.1f", pos.X, pos.Y, pos.Z)
                setclipboard(positionText)
                OrionLib:MakeNotification({
                    Name = "Position Copied",
                    Content = "Position copied: " .. positionText,
                    Time = 3
                })
            else
                OrionLib:MakeNotification({
                    Name = "Error",
                    Content = "Cannot get current position",
                    Time = 2
                })
            end
        end)
        
        if not success then
            OrionLib:MakeNotification({
                Name = "Error",
                Content = "Error copying position: " .. tostring(err),
                Time = 2
            })
        end
    end
})

-- Script Controls section removed as requested

-- Enhanced Anti AFK Loop with multiple methods
task.spawn(function()
    local Players = game:GetService("Players")
    local VirtualUser = game:GetService("VirtualUser")
    local LocalPlayer = Players.LocalPlayer
    
    -- Method 1: Handle Idled event directly
    LocalPlayer.Idled:Connect(function()
        if antiAfkEnabled then
            local success, err = pcall(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
            
            if success then
                OrionLib:MakeNotification({
                    Name = "Anti AFK",
                    Content = "Prevented AFK kick!",
                    Time = 2
                })
            else
                warn("Anti AFK method 1 failed: " .. tostring(err))
            end
        end
    end)
    
    -- Method 2: Periodic virtual input
    while scriptRunning do
        if antiAfkEnabled then
            local success, err = pcall(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
                
                -- Additional method: Move character slightly
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    local humanoid = LocalPlayer.Character.Humanoid
                    humanoid:Move(Vector3.new(0.1, 0, 0), false)
                    task.wait(0.1)
                    humanoid:Move(Vector3.new(-0.1, 0, 0), false)
                end
            end)
            
            if not success then
                warn("Anti AFK method 2 failed: " .. tostring(err))
            end
        end
        task.wait(300) -- Check every 5 minutes
    end
end)

-- Auto All Rune Loop
task.spawn(function()
    local runeOrder = {
        {name = "5M Beginner", path = "workspace.Areas['Spawn Island'].Beginner.Basic.Button"},
        {name = "5M Royal", path = "workspace.Areas['Spawn Island'].Royal.Basic.Button"},
        {name = "Basic Rune", path = "workspace.Areas['Spawn Island'].Basic.Basic.Button"},
        {name = "Color Rune", path = "workspace.Areas['Spawn Island'].Color.Color.Button"},
        {name = "Nature Rune", path = "workspace.Areas['Spawn Island'].Nature.Nature.Button"},
        {name = "Polychrome Rune", path = "workspace.Areas['Spawn Island'].Polychrome.Polychrome.Button"},
        {name = "Cryo Rune", path = "workspace.Areas.Arctic.Cryo.Cryo.Button"},
        {name = "Arctic Rune", path = "workspace.Areas.Arctic.Arctic.Arctic.Button"}
    }
    
    while scriptRunning do
        if autoAllRuneEnabled then
            for _, rune in ipairs(runeOrder) do
                if not autoAllRuneEnabled or not scriptRunning then break end
                
                local success, err = pcall(function()
                    local button
                    if rune.name == "5M Beginner" then
                        button = workspace.Areas["Spawn Island"].Beginner.Basic.Button
                    elseif rune.name == "5M Royal" then
                        button = workspace.Areas["Spawn Island"].Royal.Basic.Button
                    elseif rune.name == "Basic Rune" then
                        button = workspace.Areas["Spawn Island"].Basic.Basic.Button
                    elseif rune.name == "Color Rune" then
                        button = workspace.Areas["Spawn Island"].Color.Color.Button
                    elseif rune.name == "Nature Rune" then
                        button = workspace.Areas["Spawn Island"].Nature.Nature.Button
                    elseif rune.name == "Polychrome Rune" then
                        button = workspace.Areas["Spawn Island"].Polychrome.Polychrome.Button
                    elseif rune.name == "Cryo Rune" then
                        button = workspace.Areas.Arctic.Cryo.Cryo.Button
                    elseif rune.name == "Arctic Rune" then
                        button = workspace.Areas.Arctic.Arctic.Arctic.Button
                    end
                    
                    if button and button.CFrame then
                        local pos = button.CFrame.Position
                        teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
                    else
                        error("Button not found for " .. rune.name)
                    end
                end)
                
                if not success then
                    warn("Auto All Rune error for " .. rune.name .. ": " .. tostring(err))
                end
                
                task.wait(autoAllRuneSpeed) -- Wait based on speed setting between each rune teleport
            end
        end
         task.wait(0.1) -- Small wait to prevent lag
     end
 end)

-- Auto Rune Loop (Single Rune)
task.spawn(function()
    while scriptRunning do
        if autoRuneEnabled and selectedRune then
            local success, err = pcall(function()
                local button
                if selectedRune == "5M Beginner" then
                    button = workspace.Areas["Spawn Island"].Beginner.Basic.Button
                elseif selectedRune == "5M Royal" then
                    button = workspace.Areas["Spawn Island"].Royal.Basic.Button
                elseif selectedRune == "Basic Rune" then
                    button = workspace.Areas["Spawn Island"].Basic.Basic.Button
                elseif selectedRune == "Color Rune" then
                    button = workspace.Areas["Spawn Island"].Color.Color.Button
                elseif selectedRune == "Nature Rune" then
                    button = workspace.Areas["Spawn Island"].Nature.Nature.Button
                elseif selectedRune == "Polychrome Rune" then
                    button = workspace.Areas["Spawn Island"].Polychrome.Polychrome.Button
                elseif selectedRune == "Cryo Rune" then
                    button = workspace.Areas.Arctic.Cryo.Cryo.Button
                elseif selectedRune == "Arctic Rune" then
                    button = workspace.Areas.Arctic.Arctic.Arctic.Button
                end
                
                if button and button.CFrame then
                    local pos = button.CFrame.Position
                    teleportToPosition(Vector3.new(pos.X, pos.Y + 5, pos.Z))
                else
                    error("Button not found for " .. selectedRune)
                end
            end)
            
            if not success then
                warn("Auto Rune error for " .. selectedRune .. ": " .. tostring(err))
            end
            
            task.wait(autoAllRuneSpeed) -- Use same speed setting as Auto All Rune
        end
        task.wait(0.1) -- Small wait to prevent lag
    end
end)

-- Auto Upgrade Loop with error handling
task.spawn(function()
    while scriptRunning do
        local success, err = pcall(function()
            if autoUpgradeEnabled and BuyUpgrade and scriptRunning then
                local currentUpgradeList
                
                if selectedUpgradeType == "W1" then
                    currentUpgradeList = upgradeListW1
                elseif selectedUpgradeType == "W2" then
                    currentUpgradeList = upgradeListW2
                elseif selectedUpgradeType == "W1+W2" then
                    currentUpgradeList = upgradeListW1W2
                end
                
                if currentUpgradeList then
                    for _, upgrade in ipairs(currentUpgradeList) do
                        if autoUpgradeEnabled and scriptRunning then
                            for i = 1, upgrade.times do
                                if autoUpgradeEnabled and scriptRunning then
                                    safeFireServer(BuyUpgrade, upgrade.name)
                                    task.wait(0.05)
                                else
                                    break
                                end
                            end
                        else
                            break
                        end
                    end
                end
            end
        end)
        
        if not success then
            warn("Auto Upgrade error: " .. tostring(err))
        end
        
        task.wait(15) -- Wait 15 seconds before repeating
    end
end)

-- Function to convert game value to actual value using formula: x = 10^(y-|y|) * e^|y|
local function toScientificNotation(gameValue)
    -- Convert to number if it's a string
    local y = tonumber(gameValue)
    
    -- Check if conversion was successful
    if not y then
        return "Invalid"
    end
    
    if y == 0 then
        return "0"
    end
    
    -- |y| lÃ  pháº§n nguyÃªn cá»§a y
    local integerPart = math.floor(math.abs(y))
    
    -- Ãp dá»¥ng cÃ´ng thá»©c: x = 10^(y-|y|) * e^|y|
    -- Trong Ä‘Ã³: y-|y| lÃ  pháº§n tháº­p phÃ¢n
    local fractionalPart = y - integerPart
    
    -- TÃ­nh x = 10^(fractionalPart) * e^(integerPart)
    local mantissa = (10 ^ fractionalPart) * math.exp(integerPart)
    
    -- Chuyá»ƒn vá» dáº¡ng scientific notation
    if mantissa == 0 then
        return "0"
    end
    
    local logMantissa = math.log10(mantissa)
    local exponent = math.floor(logMantissa)
    local coefficient = mantissa / (10 ^ exponent)
    
    return string.format("%.2fe%d", coefficient, exponent)
end

-- Function to safely get value from Roblox Value objects
local function getValueSafely(valueObject)
    if not valueObject then return 0 end
    
    local rawValue
    
    -- Handle different types of Value objects
    if valueObject.ClassName == "IntValue" or valueObject.ClassName == "NumberValue" then
        rawValue = valueObject.Value
    elseif valueObject.ClassName == "StringValue" then
        rawValue = valueObject.Value
    else
        -- Fallback: try .Value property first, then .Text
        rawValue = valueObject.Value or valueObject.Text
    end
    
    if not rawValue then return 0 end
    
    -- Handle special format like "1;379.57798284067246"
    if type(rawValue) == "string" then
        -- Check if it contains semicolon (special format)
        if rawValue:find(";") then
            local parts = {}
            for part in rawValue:gmatch("[^;]+") do
                table.insert(parts, part)
            end
            -- Return the second part (actual value) if it exists
            if #parts >= 2 then
                local numValue = tonumber(parts[2])
                return numValue or 0
            end
        end
        
        -- Try to convert string to number directly
        local numValue = tonumber(rawValue)
        return numValue or 0
    else
        -- If it's already a number, return it
        return tonumber(rawValue) or 0
    end
end

-- Function to get current values
local function updateValues()
    local success, err = pcall(function()
        local player = game:GetService("Players").LocalPlayer
        
        -- Get Prisms Value using direct path
        local prismsStats = game:GetService("Players").LocalPlayer.Stats.Prisms
        if prismsStats then
            local numValue = getValueSafely(prismsStats)
            prismsValue = numValue
            local scientificValue = toScientificNotation(prismsValue)
            PrismsLabel:Set("Prisms: " .. scientificValue)
        else
            PrismsLabel:Set("Prisms: Not Available")
        end
            
        -- Get Chromium Value using direct path
        local chromiumStats = game:GetService("Players").LocalPlayer.Stats.Chromium
        if chromiumStats then
            local numValue = getValueSafely(chromiumStats)
            chromiumValue = numValue
            local scientificValue = toScientificNotation(chromiumValue)
            ChromiumLabel:Set("Chromium: " .. scientificValue)
        else
            ChromiumLabel:Set("Chromium: Not Available")
        end
            
        -- Get Energy Value using direct path
        local energyStats = game:GetService("Players").LocalPlayer.Stats.Energy
        if energyStats then
            local numValue = getValueSafely(energyStats)
            local scientificValue = toScientificNotation(numValue)
            EnergyLabel:Set("Energy: " .. scientificValue)
        else
            EnergyLabel:Set("Energy: Not Available")
        end
            
        -- Get Flame Value using direct path
        local flameStats = game:GetService("Players").LocalPlayer.Stats.Flame
        if flameStats then
            local numValue = getValueSafely(flameStats)
            local scientificValue = toScientificNotation(numValue)
            FlameLabel:Set("Flame: " .. scientificValue)
        else
            FlameLabel:Set("Flame: Not Available")
        end
            
        -- Get Power Value using direct path
        local powerStats = game:GetService("Players").LocalPlayer.Stats.Power
        if powerStats then
            local numValue = getValueSafely(powerStats)
            local scientificValue = toScientificNotation(numValue)
            PowerLabel:Set("Power: " .. scientificValue)
        else
            PowerLabel:Set("Power: Not Available")
        end
            
        -- Get Realm Points Value using direct path
        local rpStats = game:GetService("Players").LocalPlayer.Stats["Realm Points"]
        if rpStats then
            local numValue = getValueSafely(rpStats)
            local scientificValue = toScientificNotation(numValue)
            RPLabel:Set("Realm Points: " .. scientificValue)
        else
            RPLabel:Set("Realm Points: Not Available")
        end
            
        -- Get Flesh Value using direct path
        local fleshStats = game:GetService("Players").LocalPlayer.Stats.Flesh
        if fleshStats then
            local numValue = getValueSafely(fleshStats)
            local scientificValue = toScientificNotation(numValue)
            FleshLabel:Set("Flesh: " .. scientificValue)
        else
            FleshLabel:Set("Flesh: Not Available")
        end
            
        -- Get Arctic Points Value using direct path
        local apStats = game:GetService("Players").LocalPlayer.Stats.ArcticPoints
        if apStats then
            local numValue = getValueSafely(apStats)
            local scientificValue = toScientificNotation(numValue)
            APLabel:Set("Arctic Points: " .. scientificValue)
        else
            APLabel:Set("Arctic Points: Not Available")
        end
        
        -- Get Chromatizer Price (keep original format, no scientific notation)
        local chromatizeButton = workspace:FindFirstChild("Layers")
        if chromatizeButton then
            chromatizeButton = chromatizeButton:FindFirstChild("Chromatizer")
            if chromatizeButton then
                chromatizeButton = chromatizeButton:FindFirstChild("Chromatize")
                if chromatizeButton then
                    chromatizeButton = chromatizeButton:FindFirstChild("Button")
                    if chromatizeButton then
                        chromatizeButton = chromatizeButton:FindFirstChild("BillboardGui")
                        if chromatizeButton then
                            chromatizeButton = chromatizeButton:FindFirstChild("Price")
                            if chromatizeButton and chromatizeButton.Text then
                                ChromatizerPriceLabel:Set("Chromatizer Price: " .. chromatizeButton.Text)
                            else
                                ChromatizerPriceLabel:Set("Chromatizer Price: Not Available")
                            end
                        else
                            ChromatizerPriceLabel:Set("Chromatizer Price: BillboardGui Not Found")
                        end
                    else
                        ChromatizerPriceLabel:Set("Chromatizer Price: Button Not Found")
                    end
                else
                    ChromatizerPriceLabel:Set("Chromatizer Price: Chromatize Not Found")
                end
            else
                ChromatizerPriceLabel:Set("Chromatizer Price: Chromatizer Not Found")
            end
        else
            ChromatizerPriceLabel:Set("Chromatizer Price: Layers Not Found")
        end
    end)
    
    if not success then
        warn("Value update error: " .. tostring(err))
        PrismsLabel:Set("Prisms: Error - " .. tostring(err))
        ChromiumLabel:Set("Chromium: Error - " .. tostring(err))
        EnergyLabel:Set("Energy: Error - " .. tostring(err))
        FlameLabel:Set("Flame: Error - " .. tostring(err))
        PowerLabel:Set("Power: Error - " .. tostring(err))
        RPLabel:Set("Realm Points: Error - " .. tostring(err))
        FleshLabel:Set("Flesh: Error - " .. tostring(err))
        APLabel:Set("Arctic Points: Error - " .. tostring(err))
        ChromatizerPriceLabel:Set("Chromatizer Price: Error - " .. tostring(err))
    end
end

-- Function to check and auto chromatize
local function autoChromatize()
    local success, err = pcall(function()
        if not autoChromatizeEnabled then return end
        
        -- Get current chromatizer price with safe navigation
        local layers = workspace:FindFirstChild("Layers")
        if not layers then return end
        
        local chromatizer = layers:FindFirstChild("Chromatizer")
        if not chromatizer then return end
        
        local chromatize = chromatizer:FindFirstChild("Chromatize")
        if not chromatize then return end
        
        local button = chromatize:FindFirstChild("Button")
        if not button then return end
        
        local billboardGui = button:FindFirstChild("BillboardGui")
        if not billboardGui then return end
        
        local priceLabel = billboardGui:FindFirstChild("Price")
        if priceLabel and priceLabel.Text then
            local priceText = priceLabel.Text
            local priceNumber = tonumber(priceText:match("%d+"))
            
            if priceNumber and prismsValue >= priceNumber then
                -- Click chromatizer button
                safeFireServer(game:GetService("ReplicatedStorage").Remotes.Chromatize)
                OrionLib:MakeNotification({
                    Name = "Auto Chromatizer",
                    Content = "Chromatized! Price: " .. priceText,
                    Time = 2
                })
            end
        end
    end)
    
    if not success then
        warn("Auto chromatize error: " .. tostring(err))
    end
end

-- Values monitor and auto chromatizer loop
task.spawn(function()
    while scriptRunning do
        updateValues()
        autoChromatize()
        task.wait(chromatizeCheckInterval)
    end
end)

-- Update position label periodically with error handling
task.spawn(function()
    while scriptRunning do
        local success, err = pcall(function()
            if PositionLabel and PositionLabel.Set and scriptRunning then
                local newPosition = getCurrentPosition()
                if newPosition ~= currentPosition then
                    currentPosition = newPosition
                    PositionLabel:Set("Position: " .. currentPosition)
                end
            end
        end)
        
        if not success then
            warn("Position update error: " .. tostring(err))
        end
        
        task.wait(2)
    end
end)

-- Initialize GUI with validation and mobile enhancements
local success, err = pcall(function()
    if OrionLib and OrionLib.Init then
        OrionLib:Init()
    else
        error("OrionLib not properly loaded")
    end
end)

if not success then
    warn("Failed to initialize OrionLib: " .. tostring(err))
    return -- Exit script if OrionLib fails to initialize
end

-- Additional mobile optimizations after GUI is fully loaded
task.spawn(function()
    task.wait(2) -- Wait for GUI to fully load
    
    local function enhanceMobileExperience()
        local success, err = pcall(function()
            local UserInputService = game:GetService("UserInputService")
            if UserInputService.TouchEnabled then
                local coreGui = game:GetService("CoreGui")
                
                -- Find and enhance all GUI elements
                for _, gui in pairs(coreGui:GetChildren()) do
                    if gui.Name:find("Orion") then
                        for _, descendant in pairs(gui:GetDescendants()) do
                            -- Enhance buttons for mobile
                            if descendant:IsA("TextButton") or descendant:IsA("ImageButton") then
                                descendant.AutoButtonColor = true
                                descendant.Active = true
                                
                                -- Increase touch area for small buttons
                                if descendant.Size.X.Offset < 50 or descendant.Size.Y.Offset < 30 then
                                    descendant.Size = UDim2.new(
                                        descendant.Size.X.Scale,
                                        math.max(descendant.Size.X.Offset, 50),
                                        descendant.Size.Y.Scale,
                                        math.max(descendant.Size.Y.Offset, 30)
                                    )
                                end
                            end
                            
                            -- Enhance sliders for mobile
                            if descendant:IsA("Frame") and (descendant.Name:find("Slider") or descendant.Name:find("Bar")) then
                                descendant.Active = true
                                
                                -- Make slider handles larger for mobile
                                for _, child in pairs(descendant:GetChildren()) do
                                    if child:IsA("Frame") and child.Name:find("Handle") then
                                        child.Size = UDim2.new(0, 20, 1, 0) -- Larger handle
                                    end
                                end
                            end
                            
                            -- Enhance text inputs for mobile
                            if descendant:IsA("TextBox") then
                                descendant.ClearTextOnFocus = false
                                descendant.Active = true
                            end
                        end
                    end
                end
            end
        end)
        
        if not success then
            warn("Mobile enhancement failed: " .. tostring(err))
        end
end

-- Enhanced notification system without Image parameter
local function showNotification(title, content, duration)
    duration = duration or 5
    local success, err = pcall(function()
        OrionLib:MakeNotification({
            Name = title,
            Content = content,
            Time = duration
            -- Image parameter completely removed to prevent Frame errors
        })
    end)
    
    if not success then
        warn("Notification failed: " .. tostring(err))
        -- Fallback to print if notification fails
        print("[" .. title .. "] " .. content)
    end
end

-- Script completion notification
showNotification(
    "âœ… Script Loaded Successfully!", 
    "Ascender Incremental Hub is ready to use. All HTTP 404 errors have been fixed with multiple fallback sources.",
    8
)

print("ðŸŽ‰ Ascender Incremental Hub loaded successfully!")
print("ðŸ“ All OrionLib Image parameters removed to prevent Frame errors")
print("ðŸ”§ Multiple fallback sources implemented for reliability")
print("ðŸ“± Mobile optimizations enabled")
print("âš¡ Enhanced error handling active")
print("")
print("If you encounter any issues, please check:")
print("1. HttpService is enabled in game settings")
print("2. Your internet connection is stable")
print("3. The game allows HTTP requests")
print("")
print("Script by: Ascender Incremental Community")
print("Version: Fixed HTTP 404 Edition")
print("Last updated: " .. os.date("%Y-%m-%d %H:%M:%S"))
    end
    
    enhanceMobileExperience()
end)

-- Load default config on startup
local function initializeConfig()
    local success, err = pcall(function()
        loadConfig(defaultConfigName)
    end)
    
    if not success then
        OrionLib:MakeNotification({
            Name = "Config Warning",
            Content = "Failed to load default config, using built-in defaults",
            Time = 3
        })
    end
end

initializeConfig()

-- Script loaded notification with mobile detection
local deviceType = game:GetService("UserInputService").TouchEnabled and "Mobile" or "PC"
OrionLib:MakeNotification({
    Name = "Ascender Incremental Hub",
    Content = "Script loaded successfully on " .. deviceType .. "! Welcome to Ascender Incremental Hub!",
    Time = 5
})

-- Additional mobile instructions
if game:GetService("UserInputService").TouchEnabled then
    task.wait(2)
    OrionLib:MakeNotification({
        Name = "Mobile Tips",
        Content = "Mobile optimizations applied! Use 'Toggle GUI (Mobile)' button if keybind doesn't work.",
        Time = 7
    })
end

print("Ascender Incremental GUI Script loaded successfully on " .. deviceType .. "!")
